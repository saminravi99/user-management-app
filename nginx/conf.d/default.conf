# Server configuration for User Management Application
# This file defines how Nginx routes traffic to frontend and backend containers

# Upstream block for backend API servers
# This allows load balancing if you scale backend to multiple containers
upstream backend_api {
    # Use least connections algorithm for load balancing
    least_conn;
    
    # Backend container(s) - Docker Compose service name and port
    server backend:5000 max_fails=3 fail_timeout=30s;
    
    # Add more backend servers here for horizontal scaling:
    # server backend2:5000 max_fails=3 fail_timeout=30s;
    # server backend3:5000 max_fails=3 fail_timeout=30s;
    
    # Keep connections alive to backend
    keepalive 32;
}

# Upstream block for frontend Next.js server
upstream frontend_app {
    # Frontend container - Docker Compose service name and port
    server frontend:3000 max_fails=3 fail_timeout=30s;
    
    # Keep connections alive to frontend
    keepalive 32;
}

# Main server block - handles all HTTP traffic
server {
    # Listen on port 80 (HTTP)
    listen 80;
    listen [::]:80;  # IPv6 support
    
    # Server name - replace with your domain name
    # For now using underscore (default server) which matches any domain
    server_name _;  # TODO: Replace with your domain: example.com www.example.com
    
    # Maximum request body size (for file uploads)
    client_max_body_size 20M;
    
    # Root directory (not used since we're proxying, but good to define)
    root /usr/share/nginx/html;
    
    # Default character set
    charset utf-8;

    # ==========================================
    # BACKEND API ROUTES
    # All requests to /api/* are proxied to backend
    # ==========================================
    location /api {
        # Proxy to backend upstream
        proxy_pass http://backend_api;
        
        # Preserve original request information
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # WebSocket support (if needed for real-time features)
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Timeouts for backend communication
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # Buffering settings
        proxy_buffering on;
        proxy_buffer_size 4k;
        proxy_buffers 8 4k;
        proxy_busy_buffers_size 8k;
        
        # Don't cache API responses by default
        add_header Cache-Control "no-cache, no-store, must-revalidate";
        add_header Pragma "no-cache";
        add_header Expires "0";
    }

    # ==========================================
    # STATIC FILES FROM BACKEND (if any)
    # Examples: uploaded files, generated PDFs, etc.
    # ==========================================
    location /uploads {
        proxy_pass http://backend_api;
        
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # Cache static files for 1 day
        expires 1d;
        add_header Cache-Control "public, immutable";
    }

    # ==========================================
    # NEXT.JS STATIC FILES
    # Next.js serves static files from /_next/*
    # These should be cached aggressively
    # ==========================================
    location /_next/static {
        proxy_pass http://frontend_app;
        
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        
        # Cache Next.js static files for 1 year (they have content hashes)
        expires 365d;
        add_header Cache-Control "public, immutable";
        
        # Allow CORS for static assets
        add_header Access-Control-Allow-Origin *;
    }

    # ==========================================
    # NEXT.JS PUBLIC FOLDER
    # Static assets like images, fonts, etc.
    # ==========================================
    location ~ ^/(favicon\.ico|robots\.txt|sitemap\.xml) {
        proxy_pass http://frontend_app;
        
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        
        # Cache for 7 days
        expires 7d;
        add_header Cache-Control "public";
    }

    # ==========================================
    # FRONTEND APPLICATION
    # All other requests go to Next.js frontend
    # This should be the last location block (catch-all)
    # ==========================================
    location / {
        # Proxy to frontend upstream
        proxy_pass http://frontend_app;
        
        # Preserve original request information
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # WebSocket support for Next.js hot reload in development
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # Don't cache HTML pages
        add_header Cache-Control "no-cache, must-revalidate";
    }

    # ==========================================
    # HEALTH CHECK ENDPOINT
    # Used by Docker, load balancers, monitoring tools
    # ==========================================
    location /health {
        access_log off;  # Don't log health checks
        return 200 "OK\n";
        add_header Content-Type text/plain;
    }

    # ==========================================
    # ERROR PAGES
    # Custom error pages for better UX
    # ==========================================
    error_page 404 /404.html;
    error_page 500 502 503 504 /50x.html;
    
    location = /50x.html {
        root /usr/share/nginx/html;
    }
}

# ==========================================
# HTTPS SERVER BLOCK (for production with SSL)
# Uncomment and configure when you have SSL certificates
# ==========================================
# server {
#     listen 443 ssl http2;
#     listen [::]:443 ssl http2;
#     
#     server_name example.com www.example.com;  # Your domain
#     
#     # SSL certificate paths (Let's Encrypt example)
#     ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
#     ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
#     
#     # SSL configuration (modern, secure settings)
#     ssl_protocols TLSv1.2 TLSv1.3;
#     ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
#     ssl_prefer_server_ciphers off;
#     
#     # SSL session cache
#     ssl_session_cache shared:SSL:10m;
#     ssl_session_timeout 10m;
#     
#     # HSTS (force HTTPS for 1 year)
#     add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
#     
#     # Include all the same location blocks from HTTP server above
#     # ... (copy all location blocks here)
# }

# ==========================================
# HTTP to HTTPS redirect (for production)
# Uncomment when you have SSL configured
# ==========================================
# server {
#     listen 80;
#     listen [::]:80;
#     server_name example.com www.example.com;
#     
#     # Redirect all HTTP to HTTPS
#     return 301 https://$server_name$request_uri;
# }
