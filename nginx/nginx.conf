############################################################################
# NGINX MAIN CONFIGURATION FILE
# 
# WHY: This is the master configuration file that tells Nginx how to behave
#      It is the brain of the entire web server which controls everything
#
# WHAT: Nginx is a reverse proxy and web server that sits in front of your
#       application. It handles incoming requests from users and routes them
#       to the correct service (frontend or backend)
#
# HOW: This file configures:
#      - How many worker processes to run (handles concurrent connections)
#      - How to log requests and errors
#      - Performance optimizations (compression, caching, timeouts)
#      - Security headers to protect against common attacks
#
# WHERE: This file is loaded first when Nginx starts. It then includes other
#        config files from /etc/nginx/conf.d/ for specific routing rules
#
# WHEN: These settings are applied when:
#       - Nginx container starts up
#       - Nginx reloads its configuration (nginx -s reload)
############################################################################

user nginx;

worker_processes auto;
# Explanation: This tells Nginx how many worker processes to create
# "auto" means: detect the number of CPU cores and create one worker per core
# Why this matters: More workers = handle more simultaneous connections
# Example: If your server has 4 CPU cores, Nginx creates 4 workers

error_log /var/log/nginx/error.log warn;
# Explanation: Where to write error logs and what level of detail
# "warn" level includes: warnings, errors, and critical issues (not minor info)
# You can check these logs when something goes wrong to debug issues

pid /var/run/nginx.pid;
# Explanation: This file stores the process ID of the running Nginx
# Used by system tools to manage Nginx (stop, restart, check status)

############################################################################
# EVENTS BLOCK - Controls connection handling
############################################################################
events {
    worker_connections 1024;
    # Explanation: Maximum number of connections each worker can handle at once
    # Math: If you have 4 workers × 1024 connections = 4096 total connections
    # Why 1024: Good default for most applications. Increase if you have many users

    use epoll;
    # Explanation: The method Nginx uses to handle connections efficiently
    # "epoll" is Linux-specific and very fast at handling thousands of connections
    # It's like having a really efficient receptionist managing incoming calls

    multi_accept on;
    # Explanation: Accept multiple new connections at once instead of one at a time
    # This speeds up handling bursts of traffic (many users hitting your site at once)
}

############################################################################
# HTTP BLOCK - Main web server configuration
############################################################################
http {
    include /etc/nginx/mime.types;
    # Explanation: This file contains mappings of file extensions to content types
    # Example: .html → text/html, .jpg → image/jpeg, .json → application/json
    # Why needed: Tells browsers how to interpret different file types

    default_type application/octet-stream;
    # Explanation: If Nginx can't figure out the file type, use this as fallback
    # "octet-stream" means "binary data" - browser will prompt to download it

    ########################################################################
    # LOGGING CONFIGURATION - Track what's happening
    ########################################################################
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for" '
                    'rt=$request_time uct="$upstream_connect_time" '
                    'uht="$upstream_header_time" urt="$upstream_response_time"';
    # Explanation: Custom format for access logs with detailed information
    # $remote_addr: User's IP address (who made the request)
    # $request: What they requested (GET /api/users, POST /api/login, etc.)
    # $status: Response code (200 = success, 404 = not found, 500 = error)
    # $request_time: How long the entire request took
    # Why useful: Debug performance issues, track API usage, monitor errors

    access_log /var/log/nginx/access.log main;
    # Explanation: Every request gets logged here using the format above
    # You can analyze these logs to see traffic patterns, popular pages, etc.

    ########################################################################
    # PERFORMANCE OPTIMIZATIONS - Make things faster
    ########################################################################
    sendfile on;
    # Explanation: Use kernel's sendfile() system call for file transfers
    # Technical: Instead of reading file into memory then sending, send directly
    # Result: Much faster file serving, lower CPU usage

    tcp_nopush on;
    # Explanation: Send full packets instead of small chunks
    # Why: Reduces network overhead when sending files
    # Works with sendfile to maximize efficiency

    tcp_nodelay on;
    # Explanation: Disable Nagle's algorithm that batches small packets
    # Why: Lower latency for real-time connections (WebSockets, API calls)
    # Trade-off: Slight increase in bandwidth usage for faster response

    keepalive_timeout 65;
    # Explanation: Keep connections open for 65 seconds after last request
    # Why: If user makes another request within 65s, reuse same connection
    # Result: Faster subsequent requests, less overhead
    # Example: User loads page, then clicks link - reuses connection

    types_hash_max_size 2048;
    # Explanation: Size of hash table for MIME types lookup
    # Higher = faster lookups when serving many different file types
    # Default is 1024, we doubled it for better performance

    client_max_body_size 20M;
    # Explanation: Maximum size of request body (file uploads, POST data)
    # 20M = 20 megabytes - allows uploading reasonably sized files
    # Adjust higher if users need to upload large files (videos, documents)

    ########################################################################
    # GZIP COMPRESSION - Reduce bandwidth usage
    ########################################################################
    gzip on;
    # Explanation: Enable compression of responses before sending to browser
    # Result: Faster page loads, less bandwidth usage
    # Example: 1MB file compressed to 200KB - 80% reduction!

    gzip_vary on;
    # Explanation: Add "Vary: Accept-Encoding" header
    # Why: Tells CDNs/proxies to cache compressed and uncompressed versions separately
    # Some old browsers don't support compression, they get uncompressed version

    gzip_proxied any;
    # Explanation: Compress responses even if they come from proxied servers
    # Our setup: Backend responses get compressed before sending to client

    gzip_comp_level 6;
    # Explanation: Compression strength (1-9)
    # 1 = fast but less compression, 9 = slow but max compression
    # 6 = sweet spot - good compression without too much CPU usage

    gzip_types text/plain text/css text/xml text/javascript 
               application/json application/javascript application/xml+rss 
               application/rss+xml font/truetype font/opentype 
               application/vnd.ms-fontobject image/svg+xml;
    # Explanation: Which file types to compress
    # Include: Text files, CSS, JavaScript, JSON, fonts
    # Exclude: Already compressed files (images, videos) - waste of CPU
    # Note: HTML is always compressed by default

    gzip_disable "msie6";
    # Explanation: Don't compress for Internet Explorer 6
    # Why: IE6 has bugs with gzip compression
    # Who cares: Nobody uses IE6 anymore, but kept for compatibility

    ########################################################################
    # SECURITY HEADERS - Protect against attacks
    ########################################################################
    add_header X-Frame-Options "SAMEORIGIN" always;
    # Explanation: Prevent clickjacking attacks
    # "SAMEORIGIN" means: Page can only be embedded in iframes from same domain
    # Prevents: Hackers wrapping your site in invisible iframe to steal clicks

    add_header X-Content-Type-Options "nosniff" always;
    # Explanation: Stop browsers from guessing file types
    # Forces browser to respect the Content-Type header we send
    # Prevents: Uploading .txt file that browser treats as JavaScript (XSS attack)

    add_header X-XSS-Protection "1; mode=block" always;
    # Explanation: Enable browser's built-in XSS filter
    # If browser detects XSS attack, block the page instead of sanitizing
    # Note: Modern browsers have better protection, but doesn't hurt

    ########################################################################
    # SECURITY - Hide version information
    ########################################################################
    server_tokens off;
    # Explanation: Don't reveal Nginx version in error pages and headers
    # Without: "Server: nginx/1.25.0"
    # With: "Server: nginx"
    # Why: Hackers can't exploit version-specific vulnerabilities if they don't know version

    ########################################################################
    # INCLUDE ADDITIONAL CONFIGS
    ########################################################################
    include /etc/nginx/conf.d/*.conf;
    # Explanation: Load all .conf files from this directory
    # Our setup: default.conf contains routing rules for our application
    # Why separate files: Easier to organize and maintain configuration
}
