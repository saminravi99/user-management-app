################################################################################
# DOCKER COMPOSE CONFIGURATION FOR USER MANAGEMENT APPLICATION
#
# WHY: Instead of managing 5 separate containers manually, Docker Compose
#      lets us define, connect, and orchestrate all services in one file
#
# WHAT: This defines a complete multi-container application with:
#       - Nginx (reverse proxy, port 80)
#       - Frontend (Next.js React app, port 3000)
#       - Backend (Node.js API, port 5000)
#       - MongoDB (database, port 27017)
#       - Redis (cache/session store, port 6379)
#
# HOW: Docker Compose reads this file and:
#      - Creates Docker networks so containers can talk to each other
#      - Builds Docker images from Dockerfiles
#      - Starts containers in correct order (dependencies first)
#      - Monitors health checks and restarts failed containers
#      - Mounts volumes for persistent data
#
# WHERE: Run on your local machine for development, or on a server for production
#        All containers run on the same Docker host
#
# WHEN: Start everything with: docker-compose up
#       Stop everything with: docker-compose down
#
# NETWORK ARCHITECTURE:
# - frontend-network: Connects Nginx ↔ Frontend
# - backend-network: Connects Nginx ↔ Backend ↔ MongoDB/Redis
# - This isolation ensures Frontend can't directly access database (security)
################################################################################

################################################################################
# SERVICES - Define each container in our application
################################################################################
services:
  ############################################################################
  # NGINX - Reverse Proxy and Entry Point
  ############################################################################
  nginx:
    # Explanation: The front door of your application
    # Every user request hits Nginx first, which then routes to frontend or backend
    # Acts as: load balancer, SSL terminator, static file server, security layer

    build:
      context: ./nginx
      # Build from nginx directory (contains Dockerfile and config files)
      dockerfile: Dockerfile
      # Use our custom Dockerfile with optimized nginx config

    container_name: nginx-proxy
    # Human-readable name for easier log access: docker logs nginx-proxy

    ports:
      - "80:80"
      # Explanation: THE main port users connect to
      # Host port 80 → Container port 80
      # When user types http://yoursite.com, browser connects to port 80
      # This is the only port end-users need (all other services are internal)

      - "443:443"
      # HTTPS port for production with SSL/TLS certificate
      # Currently unused (no SSL configured yet)
      # When you add Let's Encrypt: users connect on 443, Nginx handles decryption

    depends_on:
      frontend:
        condition: service_healthy
        # Wait for frontend to be healthy before starting Nginx
        # Otherwise Nginx can't proxy requests (upstream unavailable error)
      backend:
        condition: service_healthy
        # Wait for backend to be healthy too
        # Ensures all upstreams are ready when Nginx starts

    networks:
      - frontend-network
      # Connected to frontend network (can reach frontend:3000)
      - backend-network
      # Connected to backend network (can reach backend:5000)
      # Nginx is the bridge between both networks

    restart: unless-stopped
    # Explanation: Auto-restart policy
    # If Nginx crashes → restart automatically
    # If you manually stop it → stay stopped
    # Good for both development and production

    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--quiet",
          "--tries=1",
          "--spider",
          "http://localhost/health",
        ]
      # Check /health endpoint (defined in our nginx config)
      # Verifies Nginx is running and responding to requests

      interval: 30s
      # Check every 30 seconds
      timeout: 5s
      # Each check must complete within 5 seconds
      retries: 3
      # Must fail 3 times before marking unhealthy
      start_period: 10s
      # Grace period: don't check for first 10 seconds (Nginx starts quickly)

  # ===========================================
  # FRONTEND - Next.js Application
  # ===========================================
  frontend:
    build:
      context: ./user-management-frontend
      dockerfile: Dockerfile
    container_name: user-management-frontend
    environment:
      NODE_ENV: production
      NEXT_PUBLIC_API_URL: /api
    depends_on:
      backend:
        condition: service_healthy
    networks:
      - frontend-network
    restart: unless-stopped
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--quiet",
          "--tries=1",
          "--spider",
          "http://localhost:3000",
        ]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 30s

  # ===========================================
  # BACKEND - Node.js API
  # ===========================================
  backend:
    build:
      context: ./user-management-backend
      dockerfile: Dockerfile
    container_name: user-management-backend
    environment:
      NODE_ENV: ${NODE_ENV:-production}
      PORT: ${PORT:-5000}
      MONGODB_URI: mongodb://${MONGO_ROOT_USER:-admin}:${MONGO_ROOT_PASSWORD:-change-this-password}@mongodb:27017/user-management?authSource=admin
      REDIS_HOST: redis
      REDIS_PORT: 6379
      JWT_ACCESS_SECRET: ${JWT_ACCESS_SECRET}
      JWT_REFRESH_SECRET: ${JWT_REFRESH_SECRET}
      JWT_ACCESS_EXPIRY: ${JWT_ACCESS_EXPIRY:-1d}
      JWT_REFRESH_EXPIRY: ${JWT_REFRESH_EXPIRY:-7d}
      SMTP_HOST: ${SMTP_HOST:-smtp.gmail.com}
      SMTP_PORT: ${SMTP_PORT:-587}
      SMTP_USER: ${SMTP_USER}
      SMTP_PASSWORD: ${SMTP_PASSWORD}
      OTP_EXPIRY: ${OTP_EXPIRY:-300}
      OTP_LENGTH: ${OTP_LENGTH:-6}
      SUPERADMIN_NAME: ${SUPERADMIN_NAME}
      SUPERADMIN_EMAIL: ${SUPERADMIN_EMAIL}
      SUPERADMIN_PASSWORD: ${SUPERADMIN_PASSWORD}
      SUPERADMIN_CONTACT: ${SUPERADMIN_CONTACT}
      FRONTEND_URL: ${FRONTEND_URL:-http://localhost:3000}
      RATE_LIMIT_WINDOW: ${RATE_LIMIT_WINDOW:-15}
      RATE_LIMIT_MAX_REQUESTS: ${RATE_LIMIT_MAX_REQUESTS:-100}
    depends_on:
      mongodb:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - backend-network
    restart: unless-stopped
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--quiet",
          "--tries=1",
          "--spider",
          "http://localhost:5000/health",
        ]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 30s

  # ===========================================
  # MONGODB - Database
  # ===========================================
  mongodb:
    image: mongo:7.0
    container_name: user-management-mongodb
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_ROOT_USER:-admin}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_ROOT_PASSWORD:-change-this-password}
      MONGO_INITDB_DATABASE: user-management
    volumes:
      - mongodb_data:/data/db
      - mongodb_config:/data/configdb
    networks:
      - backend-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # ===========================================
  # REDIS - Cache & Session Store
  # ===========================================
  redis:
    image: redis:7.2-alpine
    container_name: user-management-redis
    command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data:/data
    networks:
      - backend-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

# ===========================================
# NETWORKS - Security isolation
# ===========================================
networks:
  frontend-network:
    driver: bridge
  backend-network:
    driver: bridge

# ===========================================
# VOLUMES - Data persistence
# ===========================================
volumes:
  mongodb_data:
  mongodb_config:
  redis_data:
